/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * Chargebee API
 * OpenAPI spec version: v2 (PC 2.0)
 */
import type { AxiosInstance, AxiosResponse } from "axios";
import type {
  RetrieveATimeMachineHeaders,
  RetrieveATimeMachine200,
  TravelForwardHeaders,
  TravelForwardBody,
  TravelForward200,
  StartAfreshHeaders,
  StartAfreshBody,
  StartAfresh200,
} from "./chargebeeAPI.schemas";

export class ChargebeeTimeMachinesResource {
  constructor(private readonly axios: AxiosInstance) {}

  /**
 * Retrieves the time machine. Currently only one time machine is available per site and is named 'delorean'.

 * @summary Retrieve a time machine
 */
  public async retrieveATimeMachine(
    timeMachineName: string,
    headers?: RetrieveATimeMachineHeaders,
  ): Promise<AxiosResponse<RetrieveATimeMachine200>> {
    return this.axios.get(`/time_machines/${timeMachineName}`, {
      headers,
    });
  }

  /**
 * Travel forward in time. This operation is **asynchronous** . You need to check if the "start afresh" operation has completed by checking if the time travel status is **successful** by retrieving the time machine in a loop with a minimum delay of 3 secs between two retrieve requests. Use method **waitForTimeTravelCompletion()** on the returned time_machine resource which will block until the time travel completes.

 * @summary Travel forward
 */
  public async travelForward(
    timeMachineName: string,
    travelForwardBody: TravelForwardBody,
    headers?: TravelForwardHeaders,
  ): Promise<AxiosResponse<TravelForward200>> {
    return this.axios.post(`/time_machines/${timeMachineName}/travel_forward`, {
      headers,
      json: travelForwardBody,
    });
  }

  /**
 * Restart the time machine. This will clear the "customer" data like customer details, subscriptions, invoices, transactions. Also a time travel is initiated to travel back to specified genesis time.

**Note:** This API call is asynchronous. You need to check if the "start afresh" operation has completed by checking if the time travel status is **successful** by retrieving the time machine in a loop with a minimum delay of 3 secs between two retrieve requests. In case you are using any of the client libraries, use the **wait for time travel completion** function provided as a instance method in the library. Use method **waitForTimeTravelCompletion()** on the returned **time_machine** resource which will block until the time travel completes. Use method **waitForTimeTravelCompletion()** on the returned **time_machine** resource which will block until the time travel completes. Use method **wait_for_time_travel_completion** on the returned **time_machine** resource which will block until the time travel completes. Use method **wait_for_time_travel_completion** on the returned **time_machine** resource which will block until the time travel completes. Use method **WaitForTimeTravelCompletion** on the returned **time_machine** resource which will block until the time travel completes. Use method **wait_for_time_travel_completion** on the returned **time_machine** resource which will block until the time travel completes. Use method **waitForTimeTravelCompletion** on the returned **time_machine** resource which will block until the time travel completes. Use method **wait_for_time_travel_completion** on the returned **time_machine** resource which will block until the time travel completes.

 * @summary Start Afresh
 */
  public async startAfresh(
    timeMachineName: string,
    startAfreshBody: StartAfreshBody,
    headers?: StartAfreshHeaders,
  ): Promise<AxiosResponse<StartAfresh200>> {
    return this.axios.post(`/time_machines/${timeMachineName}/start_afresh`, {
      headers,
      json: startAfreshBody,
    });
  }
}
